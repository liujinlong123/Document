# JNI学习记录  

>Author: Aiden&#160;&#160;&#160;&#160;&#160;&#160;&#160;Date: 2020.05.25

## 文档记录  

### 文档查阅

1. 非官方文档，内容讲解非常清晰[JNI](https://www.baeldung.com/jni)  

2. 根据该[博客](http://www.mamicode.com/info-detail-2679904.html?__cf_chl_jschl_tk__=f8cf7ef10fdd82fab0ef01c550856c45d2de6c47-1590370705-0-AVo8GNhhJheXgdhMenNwUwc7g_Ac-Qcvcqy4GINEvvLFPMCqia_Wb-ZJTjMGrpiXtHVrPxFIwy7akQPk-03Zq2iBtf-LH4Y1kzSCGnmExqQzCO_poXAzyZVG8mXdMY8MEgxKctpkhQW7OP1MGei3yVjoE682mLrWJioh5mkHTdFjuLxXi1hDP0XY__SibueaUhRuVnAwTXKB80kk-SW-CvxM3dj29_C_uQT7QmHuE2yt4mVWFaVPJoMtbdwxFSvVuhV-sN2TFZmONPm0FHDMVgTv7Tlef9_xzkcJllBM7q-_RTUcEyKYJQPcu2YSp2elHQ)第一次编译成功  

## 实践整理  

### 实践一([查看博客](http://www.mamicode.com/info-detail-2679904.html?__cf_chl_jschl_tk__=f8cf7ef10fdd82fab0ef01c550856c45d2de6c47-1590370705-0-AVo8GNhhJheXgdhMenNwUwc7g_Ac-Qcvcqy4GINEvvLFPMCqia_Wb-ZJTjMGrpiXtHVrPxFIwy7akQPk-03Zq2iBtf-LH4Y1kzSCGnmExqQzCO_poXAzyZVG8mXdMY8MEgxKctpkhQW7OP1MGei3yVjoE682mLrWJioh5mkHTdFjuLxXi1hDP0XY__SibueaUhRuVnAwTXKB80kk-SW-CvxM3dj29_C_uQT7QmHuE2yt4mVWFaVPJoMtbdwxFSvVuhV-sN2TFZmONPm0FHDMVgTv7Tlef9_xzkcJllBM7q-_RTUcEyKYJQPcu2YSp2elHQ))

1. 创建`Test.java`类

    ```java
    public class Test {
        static {
            System.load("/home/aw/workLiu/project/Aosp8/test/jni/src/libnative.so");
        }

        private native void sayHello();

        public static void main(String[] args) {
            System.out.println("开始执行");
            new Test().sayHello();
            System.out.println("执行结束");
        }
    }
    ```

    >Note: `System.load(filename)`中`filename`参数传入的是全路径(绝对路径)；`System.loadLibrary(String libname)`中`libname`为动态库的名字（e.g libnative.so, 则`libname` = native）

2. 执行命令`javac -h . Test.java`生成对应的头文件

    ```bash
    > javac -h . Test.java
    ```

    执行命令后，生成文件`Test.h`, 该文件不可修改

    ```cpp
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Test */

    #ifndef _Included_Test
    #define _Included_Test
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     Test
     * Method:    sayHello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_Test_sayHello
      (JNIEnv *, jobject);

    #ifdef __cplusplus
    }
    #endif
    #endif

    ```

    >Note: javac -h [目录名] Test.java

3. 在当前目录创建对应的`Test.cpp`文件, 实现对应的方法

    ```cpp
    #include "Test.h"
    #include <iostream>

    using namespace std;

    JNIEXPORT void JNICALL Java_Test_sayHello(JNIEnv *, jobject) {
        cout << "Hello from JNI" << endl;
    }
    ```

4. 执行以下命令生成对应`so`文件, 命令[解释](https://www.cnblogs.com/cswuyg/p/3830703.html)

    ```bash
    > g++ Test.cpp -I${JAVA_HOME}/include/ -I${JAVA_HOME}/include/linux -fPIC -shared -o libTestJNI.so
    ```

    + `-I`: 指编译程序按照`-I`指定的路进去搜索头文件.  
    + `-shared`: 表明产生共享库  
    + `-fPIC`: 则表明使用地址无关代码, PIC：Position Independent Code
    + `-o`: 指定生成可执行文件的名称

5. 运行代码

    ```bash
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ javac Test.java
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ java Test
    开始执行
    Hello from JNI
    执行结束
    ```

### 实践二

1. 创建`Test.java`类  

    ```java
    public class Test {
        static {
            System.loadLibrary("native");
        }

        private native void sayHello();

        public static void main(String[] args) {
            System.out.println("第二次测试开始");

            new Test().sayHello();

            System.out.println("第二次测试结束");
        }
    }
    ```

    >Note: 与实践一中`System.load(filename)`不同, `System.loadLibrary(libname)`中`libname`只需要填名字(e.g libnative.so = 'native')

2. 编译生成`Test.h`， 执行命令  

    ```bash
    > javac -h . Test.java
    ```

    ```cpp
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Test */

    #ifndef _Included_Test
    #define _Included_Test
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     Test
     * Method:    sayHello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_Test_sayHello
      (JNIEnv *, jobject);

    #ifdef __cplusplus
    }
    #endif
    #endif

    ```

3. 创建`Test.cpp`, 实现对应方法

    ```cpp
    #include "Test.h"
    #include <iostream>

    using namespace std;

    JNIEXPORT void JNICALL Java_Test_sayHello
      (JNIEnv *, jobject) {
          cout << "Hello From C++ ！" << endl;
      }
    ```

4. 执行命令生成`.o`文件, `.o`文件是源码编译出的二进制文件

    ```bash
    > g++ -c -fPIC -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux Test.cpp -o Test.o
    ```

5. 执行命令生成`libnative.so`

    ```bash
    > g++ -shared -fPIC -o libnative.so Test.o -lc
    ```

    + `-l`: 编译程序到系统默认路进搜索，如果找不到，到当前目录，如果当前目录找不到，则到LD_LIBRARY_PATH等环境变量置顶的路进去查找，如果还找不到，那么编译程序提示找不到库
    + `-lc`: 表示使用c语言库  

6. 运行程序  

    ```bash
    > java -cp . -Djava.library.path=/NATIVE_SHARED_LIB_FOLDER Test
    ```

    ```bash
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ g++ -c -fPIC -I${JAVA_HOME}/include/ -I${JAVA_HOME}/include/linux Test.cpp -o Test.o
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ g++ -shared -fPIC -o libnative.so Test.  o -lc
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ java -cp . -Djava.library.path=. Test
    第二次测试开始
    Hello From C++ ！
    第二次测试结束
    ```

    + `-D`: 程序启动参数  
    + `java.library.path`: This way Java will know where to look for our native libs  

### 实践三(传入参数)  

1. `Test.java`

    ```java
    public class Test {
        static {
            System.loadLibrary("native");
        }

        private native long sumIntegers(int first, int second);

        private native String sayHelloToMe(String name, boolean isFemale);

        public static void main(String[] args) {
            Test test = new Test();

            System.out.println("程序开始执行");

            System.out.println("1 + 2 = " + test.sumIntegers(1, 2));

            System.out.println(test.sayHelloToMe("my name", false));

            System.out.println("程序执行结束");
        }
    }
    ```

2. `Test.cpp`

    ```cpp
    #include "Test.h"
    #include <iostream>

    using namespace std;

    JNIEXPORT jlong JNICALL Java_Test_sumIntegers
      (JNIEnv * env, jobject thisObject, jint first, jint second) {
          cout << "C++ The numbers received are: " << first << " and " << second << endl;
          return (long)first + (long)second;
      }

    JNIEXPORT jstring JNICALL Java_Test_sayHelloToMe
      (JNIEnv * env, jobject thisObject, jstring name, jboolean isFemale) {
          const char* nameCharPointer = env->GetStringUTFChars(name, NULL);
          string title;
          if (isFemale) {
              title = "Ms. ";
          } else {
              title = "Mr. ";
          }

          string fullname = title + nameCharPointer;
          return env->NewStringUTF(fullname.c_str());
      }
    ```

### 实践四(传入对象)  

1. `Test.java`

    ```java
    public class Test {
        static {
            System.loadLibrary("native");
        }

        public native User createUser(String name, double balance);

        public native String printUserData(User user);

        public static void main(String[] args) {
            Test test = new Test();

            System.out.println("开始执行");

            User user = test.createUser("my name", 12.5);

            System.out.println("创建完毕" + test.printUserData(user));
        }
    }
    ```

2. `Test.cpp`

    ```cpp
    #include "Test.h"
    #include <iostream>

    using namespace std;

    JNIEXPORT jobject JNICALL Java_Test_createUser
      (JNIEnv *env, jobject thisObject, jstring name, jdouble balance) {

          jclass userClass = env->FindClass("User");
          jobject newUser = env->AllocObject(userClass);

          jfieldID nameField = env->GetFieldID(userClass, "name", "Ljava/lang/String;");
          jfieldID balanceField = env->GetFieldID(userClass, "balance", "D");

          env->SetObjectField(newUser, nameField, name);
          env->SetDoubleField(newUser, balanceField, balance);

          return newUser;
      }

    JNIEXPORT jstring JNICALL Java_Test_printUserData
      (JNIEnv *env, jobject thisObject, jobject user) {

          jclass userClass = env->GetObjectClass(user);
          jmethodID methodId = env->GetMethodID(userClass, "getUserInfo", "()   Ljava/lang/String;");

          jstring result = (jstring)env->CallObjectMethod(user, methodId);

          return result;
      }
    ```
