# JNI学习记录  

>Author: 刘金龙&#160;&#160;&#160;&#160;&#160;&#160;&#160;Date: 2020.05.25

## 文档记录  

### 文档查阅

1. 非官方文档，内容讲解非常清晰[JNI](https://www.baeldung.com/jni)  

2. 根据该[博客](http://www.mamicode.com/info-detail-2679904.html?__cf_chl_jschl_tk__=f8cf7ef10fdd82fab0ef01c550856c45d2de6c47-1590370705-0-AVo8GNhhJheXgdhMenNwUwc7g_Ac-Qcvcqy4GINEvvLFPMCqia_Wb-ZJTjMGrpiXtHVrPxFIwy7akQPk-03Zq2iBtf-LH4Y1kzSCGnmExqQzCO_poXAzyZVG8mXdMY8MEgxKctpkhQW7OP1MGei3yVjoE682mLrWJioh5mkHTdFjuLxXi1hDP0XY__SibueaUhRuVnAwTXKB80kk-SW-CvxM3dj29_C_uQT7QmHuE2yt4mVWFaVPJoMtbdwxFSvVuhV-sN2TFZmONPm0FHDMVgTv7Tlef9_xzkcJllBM7q-_RTUcEyKYJQPcu2YSp2elHQ)第一次编译成功  

## 实践整理  

### 实践一([查看博客](http://www.mamicode.com/info-detail-2679904.html?__cf_chl_jschl_tk__=f8cf7ef10fdd82fab0ef01c550856c45d2de6c47-1590370705-0-AVo8GNhhJheXgdhMenNwUwc7g_Ac-Qcvcqy4GINEvvLFPMCqia_Wb-ZJTjMGrpiXtHVrPxFIwy7akQPk-03Zq2iBtf-LH4Y1kzSCGnmExqQzCO_poXAzyZVG8mXdMY8MEgxKctpkhQW7OP1MGei3yVjoE682mLrWJioh5mkHTdFjuLxXi1hDP0XY__SibueaUhRuVnAwTXKB80kk-SW-CvxM3dj29_C_uQT7QmHuE2yt4mVWFaVPJoMtbdwxFSvVuhV-sN2TFZmONPm0FHDMVgTv7Tlef9_xzkcJllBM7q-_RTUcEyKYJQPcu2YSp2elHQ))

1. 创建`Test.java`类

    ```java
    public class Test {
        static {
            System.load("/home/aw/workLiu/project/Aosp8/test/jni/src/libnative.so");
        }

        private native void sayHello();

        public static void main(String[] args) {
            System.out.println("开始执行");
            new Test().sayHello();
            System.out.println("执行结束");
        }
    }
    ```

    >Note: `System.load(filename)`中`filename`参数传入的是全路径(绝对路径)；`System.loadLibrary(String libname)`中`libname`为动态库的名字（e.g libnative.so, 则`libname` = native）

2. 执行命令`javac -h . Test.java`生成对应的头文件

    ```bash
    > javac -h . Test.java
    ```

    执行命令后，生成文件`Test.h`, 该文件不可修改

    ```cpp
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Test */

    #ifndef _Included_Test
    #define _Included_Test
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     Test
     * Method:    sayHello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_Test_sayHello
      (JNIEnv *, jobject);

    #ifdef __cplusplus
    }
    #endif
    #endif

    ```

    >Note: javac -h [目录名] Test.java

3. 在当前目录创建对应的`Test.cpp`文件, 实现对应的方法

    ```cpp
    #include "Test.h"
    #include <iostream>

    using namespace std;

    JNIEXPORT void JNICALL Java_Test_sayHello(JNIEnv *, jobject) {
        cout << "Hello from JNI" << endl;
    }
    ```

4. 执行以下命令生成对应`so`文件, 命令[解释](https://www.cnblogs.com/cswuyg/p/3830703.html)

    ```bash
    > g++ Test.cpp -I${JAVA_HOME}/include/ -I${JAVA_HOME}/include/linux -fPIC -shared -o libTestJNI.so
    ```

    + `-I`: 指编译程序按照`-I`指定的路进去搜索头文件.  
    + `-shared`: 表明产生共享库  
    + `-fPIC`: 则表明使用地址无关代码, PIC：Position Independent Code
    + `-o`: 指定生成可执行文件的名称

5. 运行代码

    ```bash
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ javac Test.java
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ java Test
    开始执行
    Hello from JNI
    执行结束
    ```

### 实践二

1. 创建`Test.java`类  

    ```java
    public class Test {
        static {
            System.loadLibrary("native");
        }

        private native void sayHello();

        public static void main(String[] args) {
            System.out.println("第二次测试开始");

            new Test().sayHello();

            System.out.println("第二次测试结束");
        }
    }
    ```

    >Note: 与实践一中`System.load(filename)`不同, `System.loadLibrary(libname)`中`libname`只需要填名字(e.g libnative.so = 'native')

2. 编译生成`Test.h`， 执行命令  

    ```bash
    > javac -h . Test.java
    ```

    ```cpp
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Test */

    #ifndef _Included_Test
    #define _Included_Test
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     Test
     * Method:    sayHello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_Test_sayHello
      (JNIEnv *, jobject);

    #ifdef __cplusplus
    }
    #endif
    #endif

    ```

3. 创建`Test.cpp`, 实现对应方法

    ```cpp
    #include "Test.h"
    #include <iostream>

    using namespace std;

    JNIEXPORT void JNICALL Java_Test_sayHello
      (JNIEnv *, jobject) {
          cout << "Hello From C++ ！" << endl;
      }
    ```

4. 执行命令生成`.o`文件, `.o`文件是源码编译出的二进制文件

    ```bash
    g++ -c -fPIC -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux Test.cpp -o Test.o
    ```

5. 执行命令生成`libnative.so`

    ```bash
    g++ -shared -fPIC -o libnative.so Test.o -lc
    ```

    + `-l`: 编译程序到系统默认路进搜索，如果找不到，到当前目录，如果当前目录找不到，则到LD_LIBRARY_PATH等环境变量置顶的路进去查找，如果还找不到，那么编译程序提示找不到库
    + `-lc`: 表示使用c语言库  

6. 运行程序  

    ```bash
    java -cp . -Djava.library.path=/NATIVE_SHARED_LIB_FOLDER Test
    ```

    ```bash
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ g++ -c -fPIC -I${JAVA_HOME}/include/ -I${JAVA_HOME}/include/linux Test.cpp -o Test.o
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ g++ -shared -fPIC -o libnative.so Test.  o -lc
    (base) aw@aw:~/workLiu/project/Aosp8/test/jni/src$ java -cp . -Djava.library.path=. Test
    第二次测试开始
    Hello From C++ ！
    第二次测试结束
    ```

    + `-D`: 程序启动参数  
    + `java.library.path`: This way Java will know where to look for our native libs